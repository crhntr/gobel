package es6

import "fmt"

// Token is a unit generated by the lexer whitch includes a type
// or value
type Token struct {
	Type  TokenType
	Value string
	FilePosition
}

// FilePosition represents the source where
type FilePosition struct {
	fileName             string
	offset, line, column int
}

func (pos FilePosition) String() string {
	return fmt.Sprintf("in %s at line: %d, column: %d", pos.fileName, pos.line, pos.column)
}

// Position returns the Lexer's current position
func (pos FilePosition) Position() (filename string, offset, line, column int) {
	return pos.fileName, pos.offset, pos.line, pos.column
}

func (tok Token) String() string {
	val := ""
	if len(tok.Value) > 0 {
		val = " \"" + tok.Value + "\""
	}
	return fmt.Sprintf("<%s%s at %s>", tok.Type.String(), val, tok.FilePosition)
}

// TokenType represents a golang type
type TokenType int

// not handled Type's
// TODO missing LineTerminatorSequence
const (
	ErrorToken TokenType = iota
	EOFToken
	// Comment ::
	MultiLineCommentToken
	SingleLineCommentToken
	// WhiteSpaceToken ::
	WhiteSpaceToken
	// LineTerminatorToken ::
	LineTerminatorToken
	// ComomonToken ::
	IdentifierNameToken
	ReservedWordToken
	//   Punctuator
	PunctuatorToken
	RightBracePunctuatorToken
	DivPunctuatorToken

	NumericLiteralToken
	StringLiteralToken

	// Template ::
	NoSubstitutionTemplateToken
	TemplateHeadToken
	TemplateMiddleToken
	TemplateTailToken

	// RegEx ::
	RegExToken
)

func (typ TokenType) String() string {
	switch typ {
	case ErrorToken:
		return "Error"
	case EOFToken:
		return "EOF"
	case MultiLineCommentToken:
		return "MultiLineComment"
	case SingleLineCommentToken:
		return "SingleLineComment"
	case WhiteSpaceToken:
		return "WhiteSpace"
	case LineTerminatorToken:
		return "LineTerminator"
	case IdentifierNameToken:
		return "IdentifierName"
	case ReservedWordToken:
		return "ReservedWord"
	case PunctuatorToken:
		return "Punctuator"
	case RightBracePunctuatorToken:
		return "RightBracePunctuator"
	case DivPunctuatorToken:
		return "DivPunctuator"
	case NumericLiteralToken:
		return "NumericLiteral"
	case StringLiteralToken:
		return "StringLiteral"
	case TemplateHeadToken:
		return "TemplateHead"
	case NoSubstitutionTemplateToken:
		return "NoSubstitutionTemplate"
	case TemplateMiddleToken:
		return "TemplateMiddle"
	case TemplateTailToken:
		return "TemplateTail"
	case RegExToken:
		return "RegEx"
	default:
		return "UNKNOWN_TOKEN_TYPE"
	}
}

// Equals checks if the token is equal to another token
func (tok Token) Equals(tok2 Token) bool {
	return tok.Type == tok2.Type && tok.Value == tok2.Value
}
